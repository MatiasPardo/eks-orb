version: 2.1

description: Install tools to interact with AWS EKS

examples:
  deploy:
    description: Deploy to EKS
    usage:
      version: 2.1
      orbs:
        eks: tiendanube/eks@1.0.0
      workflows:
        deploy:
          jobs:
            - eks/deploy:
                cluster_name: cluster_name
                region: region
                steps:
                  - run:
                      command: |
                        kubectl apply -f bundle.yml
                        kubectl apply -f deployment.yml

executors:
  default:
    docker:
      - image: tiendanube/circleci-eks:v1.0.0

commands:
  authenticate_eks_cluster:
    description: Authenticate to EKS Cluster
    parameters:
      cluster_name:
        type: string
        description: EKS cluster name
      region:
        type: string
        description: AWS region where the eks cluster is located
    steps:
      - run:
          name: Authenticate to EKS Cluster
          command: aws eks update-kubeconfig --name << parameters.cluster_name >> --region << parameters.region >>

jobs:
  deploy:
    description: Authenticate to eks cluster and run the steps provided
    executor: default
    parameters:
      cluster_name:
        type: string
        description: EKS cluster name
      region:
        type: string
        description: AWS region where the eks cluster is located
      steps:
        type: steps
        description: Steps to deploy your application (e.g. kubectl apply -f deployment.yml)
    steps:
      - checkout
      - authenticate_eks_cluster:
          cluster_name: << parameters.cluster_name >>
          region: << parameters.region >>
      - steps: << parameters.steps >>

  blue-green-deploy:
    description: Authenticate to eks cluster and execute a blue/green deploy
    executor: default
    parameters:
      cluster_name:
        type: string
        description: EKS cluster name
      region:
        type: string
        description: AWS region where the eks cluster is located
      deployment-name:
        type: string
        description: Deployment name
      deployment-namespace:
        type: string
        description: Deployment namespace
      service-name:
        type: string
        description: Which k8s service should be updated with the new version
      new-version:
        type: string
        description: Which version should be deployed
        default: "${CIRCLE_SHA1:0:7}"
      working-directory:
        type: string
        description: Folder where the k8s config files are located
    steps:
      - checkout
      - authenticate_eks_cluster:
          cluster_name: << parameters.cluster_name >>
          region: << parameters.region >>
      - run:
          name: Blue/Green Deploy
          working_directory: << parameters.working-directory >>
          command: |
            DEPLOYMENT_NAME=<< parameters.deployment-name >>
            DEPLOYMENT_NAMESPACE=<< parameters.deployment-namespace >>
            SERVICE_NAME=<< parameters.service-name >>
            CURRENT_VERSION=$(kubectl get service "${DEPLOYMENT_NAME}" -o=jsonpath='{.spec.selector.version}' --namespace "${DEPLOYMENT_NAMESPACE}" || true)
            NEW_VERSION=<< parameters.new-version >>

            if [[ "${CURRENT_VERSION}" == "${NEW_VERSION}" ]]; then
              echo "CURRENT_VERSION and NEW_VERSION are the same: ${CURRENT_VERSION}"
              exit 0
            fi

            if [[ -z "${CURRENT_VERSION}" ]]; then
              echo "Deployment not found, creating the first version of the application with version: ${NEW_VERSION}!"
              sed "s/VERSION/${NEW_VERSION}/g" deployment.yml | kubectl apply --namespace "${DEPLOYMENT_NAMESPACE}" -f -
              sed "s/VERSION/${NEW_VERSION}/g" service.yml | kubectl apply --namespace "${DEPLOYMENT_NAMESPACE}" -f -
              kubectl rollout status deployment/"${DEPLOYMENT_NAME}-${NEW_VERSION}" --namespace "${DEPLOYMENT_NAMESPACE}"
              exit 0
            fi

            echo "Create a new deployment"
            kubectl get deployment "${DEPLOYMENT_NAME}-${CURRENT_VERSION}" --output yaml --namespace "${DEPLOYMENT_NAMESPACE}" | sed -e "s/${CURRENT_VERSION}/${NEW_VERSION}/g" | kubectl apply --namespace "${DEPLOYMENT_NAMESPACE}" -f -

            echo "Wait for the new deployment to be available"
            kubectl rollout status deployment/"${DEPLOYMENT_NAME}-${NEW_VERSION}" --namespace "${DEPLOYMENT_NAMESPACE}"

            sleep 30

            echo "Update service to send traffic to the new deployment"
            kubectl get service "${SERVICE_NAME}" --output yaml --namespace "${DEPLOYMENT_NAMESPACE}" | sed -e "s/${CURRENT_VERSION}/${NEW_VERSION}/g" | kubectl apply --namespace "${DEPLOYMENT_NAMESPACE}" -f -

            sleep 30

            echo "Delete previous deployment version"
            kubectl delete deployment "${DEPLOYMENT_NAME}-${CURRENT_VERSION}" --namespace "${DEPLOYMENT_NAMESPACE}"

  helm-deploy:
    description: Deploy the given Helm chart to EKS Cluster
    executor: default
    parameters:
      cluster_name:
        type: string
        description: EKS cluster name
      region:
        type: string
        description: AWS region where the eks cluster is located
      s3-chart-repo:
        type: string
        description: Additional helm chart repository
        default:
      release-name:
        type: string
        description: Helm release name
      values-file:
        type: string
        description: Helm values file
      namespace:
        type: string
        description: Namespace where the chart will be installed
      chart:
        type: string
        description: Chart that will be installed
      image-tag:
        type: string
        description: Which image tag will be installed
        default: ${CIRCLE_SHA1:0:7}
    steps:
      - checkout
      - authenticate_eks_cluster:
          cluster_name: << parameters.cluster_name >>
          region: << parameters.region >>
      - when:
          condition: << parameters.s3-chart-repo >>
          name: Add additional helm repo
          steps:
            - run: helm repo add << parameters.s3-chart-repo >> s3://<< parameters.s3-chart-repo >>/
      - run:
          name: Upgrade helm chart
          command: >
            helm upgrade
            --install << parameters.release-name >>
            --values << parameters.values-file >>
            --set-string image.tag="<< parameters.image-tag >>"
            --namespace << parameters.namespace >>
            << parameters.chart >>
            --wait
      - run:
          name: Check the release status
          command: |
            sleep 10
            helm status << parameters.release-name >>
